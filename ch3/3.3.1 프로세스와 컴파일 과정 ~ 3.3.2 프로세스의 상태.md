# Section 3.3 프로세스와 스레드
> **프로세스(Process)** : 컴퓨터에서 실행되고 있는 프로그램  
> = CPU 스케줄링의 대상이 되는 `작업(task)`  
> **스레드(Thread)** : 프로세스 내 작업의 흐름을 지칭

![프로그램과 프로세스](https://github.com/user-attachments/assets/6f507fa4-9908-4938-9682-e2224af91bf5)

1. 프로그램이 메모리에 올라감.
2. 프로그램 인스턴스화 : 프로그램이 프로세스가 됨.
3. 운영체제의 CPU 스케줄러가 프로세스 생성된 후, 종료될 때까지 모든 상태 변화를 조정
4. CPU 스케줄러에 따라 CPU가 프로세스를 실행

## 3.3.1 프로세스와 컴파일 과정
> **프로세스** : 프로그램이 메모리에 올라가 인스턴스화된 것  

- 예시
    - 프로그램 : 구글 크롬 프로그램(chrome.exe)과 같은 실행 파일
    - 프로그램을 더블 클릭 시, 구글 크롬 프로세스로 변환

- 프로그램을 만드는 과정
    - C 언어 기반의 프로그램
        - 컴파일러가 컴파일 과정을 통해 컴퓨터가 이해할 수 있는 기계어로 번역하여 실행할 수 있는 파일을 만듦

        ![프로그램 컴파일 과정](https://github.com/user-attachments/assets/af8e128d-5730-4f41-a14b-e1da15f41d59)

        - **전처리** : 소스 코드의 주석 제거
            - #include 등 헤더 파일을 병합하여 매크로를 치환
        - **컴파일러** : 오류 처리, 코드 최적화 작업
            - 어셈블리어로 변환
        - **어셈블러** : 어셈블리어는 목적 코드(object code)로 변환됨.
            - 이 때, 확장자는 운영체제마다 다름
                - 리눅스 : .o
                - 예 : 하10C.c 파일을 만들었을 때, 하10C.o라는 파일이 만들어짐.
        - **링커** : 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만듦.
            - 실행파일 확장자 : .exe 또는 .out
        - **정적 라이브러리**와 **동적 라이브러리**
            > 라이브러리는 `정적 라이브러리`와 `동적 라이브러리`로 나뉨.  
            - `정적 라이브러리` : 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식으로 라이브러리를 쓰는 방법
                - 장점 : 시스템 환경 등 외부 의존도가 낮음
                - 단점 : 코드 중복 등 메모리 효율성이 떨어짐.
            - `동적 라이브러리` : 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하여 라이브러리를 쓰는 방법
                - 장점 : 메모리 효율성이 좋음
                - 단점 : 외부 의존도가 높음

## 3.3.2 프로세스의 상태
> 프로레스의 상태는 여러 가지 상태 값을 가짐.  

![프로세스 상태](https://github.com/user-attachments/assets/9701e784-3a7a-4b57-9635-45830cfd3edc)
- **생성 상태**(create) : 프로세스가 생성된 상태
    - `fork()` 또는 `exec()` 함수를 통해 생성. 이 때, PCB가 할당됨.
    - `fork()` : 부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수
        - 주소 공간만 복사
        - 부모 프로세스의 비동기 작업 등을 상속하지는 않음
    - `exec()` : 새롭게 프로세스를 생성하는 함수
- **대기 상태**(ready) : 메모리 공간이 충분하면, 메모리를 할당받고  
아니면 아닌 상태로 대기하고 있으며 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태
- **대기 중단 상태**(ready suspended) : 메모리 부족으로 일시 중단된 상태
- **실행 상태**(running) : CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태
    - ( = CPU burst가 일어났다. )
- **중단 상태**(blocked) : 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태
    - I/O 디바이스에 의한 인터럽트로 이런 현상이 많이 발생하기도 함.
    - 예 : 프린트 인쇄 버튼을 눌렀을 때, 프로세스가 잠깐 멈춘 듯할 때
- **일시 중단 상태**(blocked suspended) : 대기 중단과 유사  
    중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태
- **종료 상태**(terminated) : 메모리와 CPU 소유권을 모두 놓고 가는 상태
    - 자연스럽게 종료되는 경우
    - 비자발적 종료(abort) : 부모 프로세스가 자식 프로세스를 강제시킴
        - 자식 프로세스에 할당된 자원의 한계치를 넘어선 경우
        - 부모 프로세스가 종료된 경우
        - 사용자가 여러 명령어( *process.kill 등* )로 프로세스를 종료하는 경우
