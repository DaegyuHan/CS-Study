# Chapter 4. 데이터베이스

## Section 4.1 데이터베이스의 기본

- `데이터베이스`(DB; DataBase) : 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음
- `DBMS`(DataBase Management System) : 데이터베이스를 제어, 관리하는 통합 시스템
- 데이터베이스 안에 있는 `데이터`들은 특정 DBMS마다 정의된 쿼리 언어(`Query Language`)를 통해 **삽입**, **삭제**, **수정**, **조회** 등을 수행
- `데이터베이스`는 **실시간 접근**과 **동시 공유**가 가능

- 데이터베이스와 DBMS
    > DB 위에 DBMS가 있고 그 위에 응용프로그램이 있으며,  
    > 이러한 구조를 기반으로 데이터를 주고받음.   
    
   ![image](https://github.com/user-attachments/assets/09558323-c0b9-462a-860f-6969c3075a65)


    - 예시 : DBMS(MySQL)가 있고 응용프로그램(Node.js 혹은 php)에서 해당 데이터베이스 안에 있는 데이터를 끄집어내 해당 데이터 관련 로직을 구축 

---

### 4.1.1 엔터티(Entity)
> 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사  

- 예시
  ![엔터티](https://github.com/user-attachments/assets/32101103-f4c2-48a4-9dbe-e6e172cd0e21)
    - 엔터티 : 회원
    - 속성
        - 이름
        - 아이디
        - 주소
        - 전화번호  
        ...  
        *속성은 서비스의 요구 사항에 맞춰 정해짐.*

<BR>

#### 약한 엔터티와 강한 엔터티
> A가 혼자서는 존재하지 못하고 B의 존재성 여부에 따라 종속적인 경우,  
> `A` : 약한 엔터티  
> `B` : 강한 엔터티

- 예시 : 방은 건물 안에만 존재
    - `방` : 약한 엔터티
    - `건물` : 강한 엔터티

---

### 4.1.2 릴레이션(Relation)
> 데이터베이스에서 정보를 구분하여 저장하는 기본 단위  
> 데이터베이스는 엔터티에 관한 데이터를 릴레이션 하나에 담아서 관리

![릴레이션](https://github.com/user-attachments/assets/3a9b417b-734f-4744-990a-e0c4d9c619e8)

앞의 그림처럼 회원이라는 엔터티가 데이터베이스에서 관리될 때, 릴레이션으로 변화된 것을 볼 수 있음.

<BR>

**릴레이션**
- 관계형 DB에서 릴레이션 = `테이블`
- NoSQL DB에서 릴레이션 = `컬렉션`

<BR>

#### 테이블과 컬렉션

DB의 종류
- 관계형 DB
    - MySQL
    - 구조 : Record - Table - DB
- NoSQL DB
    - MongoDB
    - 구조 : Document - Collection - DB

![레코드-테이블-데이터베이스의 구조](https://github.com/user-attachments/assets/5cde76da-d29c-4da8-b092-17bee1ec537c)  
`레코드`가 쌓여서 `테이블`이 되고, `테이블`이 쌓여서 `데이터베이스`가 되는 것

---

### 4.1.3 속성(Attribute)
> 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보  

- 예시
    - 엔터티 : 차
    - 속성  
        > 아래 여러 속성 중, 서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔터티의 속성이 됨.  
        ( *현실 세계의 모든 속성이 엔터티의 속성이 되는 것이 아니다.* )
        - 차 번호
        - 바퀴 수
        - 차 색깔
        - 차종  
        ...

---

### 4.1.4 도메인(Domain)
> 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합  

- 예시
    - 속성 : 성별
    - 도메인    
        - 남(男)
        - 여(女)
          
    ![속성과 도메인](https://github.com/user-attachments/assets/12e86840-6038-4d92-b6df-eee50e9e0948)  
    `회원`이라는 릴레이션에 `이름`, `아이디`, `주소`, `전화번호`, `성별`이라는 속성이 있고  
    `성별`은 {`남`, `여`}라는 도메인을 가지는 것을 알 수 있습니다.

---

### 4.1.5 필드와 레코드
> 레코드( *= 튜플* ) : 테이블에 쌓이는 행(`row`) 단위의 데이터

**member**  
![필드와 레코드](https://github.com/user-attachments/assets/64c25d62-5dc2-4d23-b770-4505f3ac36d4)  

- 엔터티 : 회원
- 속성
    - 이름
    - 전화번호
- 테이블 : member
- 필드
    - name
    - phone number

<BR>

<table>
  <tr><td style="border-radius:5px; background-color:rgba(255, 255, 255, 0.5); padding:10px">
<H4> 1. <code>책</code> 엔터티를 정의하고 테이블을 만들어보자.</H4>
<ul>
  <li>엔터티 : 책</li>
  <li>속성
    <ul>
      <li>제목</li>
      <li>가격</li>
      <li>ISBN</li>
      <li>저자</li>
      <li>출판사</li>
      <li>출판년도</li>
      ...
    </ul>
  </li>
</ul>
<br>
<i>수 많은 속성 중 서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성</i><br>

<ul>
  <li>이름</li>
  <li>저자의 아이디</li>
  <li>출판년도</li>
  <li>장르</li>
  <li>생성 일시</li>
  <li>업데이트 일시</li>
</ul>
<br>
엔터티를 데이터베이스에 넣어 테이블로 만들기 위해 각 속성에 맞는 타입을 정의해야 합니다.  <br>
<i>( 타입은 데이터베이스(MongoDB, MySQL 등)마다 조금씩 차이가 있음 )</i><br>
  
MySQL 기준<br>  
<ul>
  <li><b>책의 아이디</b> : INT</li>
  <li><b>책의 제목</b> : VARCHAR(255)</li>
  <li><b>책의 저자 아이디</b> : INT</li>
  <li><b>책의 출판년도</b> : VARCHAR(255)</li>
  <li><b>책의 장르</b> : VARCHAR(255)</li>
  <li><b>생성 일시</b> : DATETIME</li>
  <li><b>업데이트 일시</b> : DATETIME</li>
</ul>

<img src="https://github.com/user-attachments/assets/e2105df8-1ddb-49f7-990d-8c3690a9e1bf" alt="book 테이블"><br>
 
<i>보통 한글을 속성명으로 사용하지 않음.<br>
위의 테이블에서도 ID, TITLE, AUTHOR_ID 등과 같이 영어 이름에 매핑해서 사용하였으며<br>
앞에서 설명한 속성과 타입들이 들어간 것을 확인할 수 있습니다.</i>

<br>

<h4>2. 테이블을 MySQL로 구현해보자.</h4>

<pre><code class="language-sql">
CREATE TABLE BOOK(
    ID INT NOT NULL AUTO_INCREMENT,
    TITLE VARCHAR(255),
    AUTHOR_ID INT,
    PUBLISHING_YEAR VARCHAR(255),
    GENRE VARCHAR(255),
    CREATED_AT DATETIME,
    UPDATED_AT DATETIME,
    PRIMARY KEY(ID)
);
</code></pre>

</td></tr></table>

<br>

#### 필드 타입
> 필드는 타입을 갖습니다.  
> 타입들은 DBMS마다 다릅니다.  
> *(여기서는 MySQL을 기준으로 설명하겠습니다.)*

- 숫자 타입
    > `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT` 등  

    <TABLE>
        <TR>
            <TH>타입</TH>
            <TH>용량(바이트)</TH>
            <TH>최솟값(부호 있음)</TH>
            <TH>최솟값(부호 없음)</TH>
            <TH>최댓값(부호 있음)</TH>
            <TH>최댓값(부호 없음)</TH>
        </TR>
        <TR>
            <TD><B>TINYINT</B></TD>
            <TD>1</TD>
            <TD>-128</TD>
            <TD>0</TD>
            <TD>127</TD>
            <TD>255</TD>
        </TR>
        <TR>
            <TD><B>SMALLINT</B></TD>
            <TD>2</TD>
            <TD>-32768</TD>
            <TD>0</TD>
            <TD>32767</TD>
            <TD>65535</TD>
        </TR>
        <TR>
            <TD><B>MEDIUMINT</B></TD>
            <TD>3</TD>
            <TD>-8388608</TD>
            <TD>0</TD>
            <TD>8388607</TD>
            <TD>16777215</TD>
        </TR>
        <TR>
            <TD><B>INT</B></TD>
            <TD>4</TD>
            <TD>-2147483648</TD>
            <TD>0</TD>
            <TD>2147483647</TD>
            <TD>4294967295</TD>
        </TR>
        <TR>
            <TD><B>BIGINT</B></TD>
            <TD>8</TD>
            <TD>-2⁶³</TD>
            <TD>0</TD>
            <TD>2⁶³-1</TD>
            <TD>2⁶⁴-1</TD>
        </TR>
    </TABLE>

- 날짜 타입
    > `DATE`, `DATETIME`, `TIMESTAMP` 등  

    - **DATE** : 날짜 부분은 있지만 시간 부분은 없는 값에 사용
        - 용량 : 3바이트
        - 지원 범위 : 1000-01-01 ~ 9999-12-31
    - **DATETIME** : 날짜 및 시간 부분을 모두 포함하는 값에 사용
        - 용량 : 8바이트
        - 지원 범위 : 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
    - **TIMESTAMP** : 날짜 및 시간 부분을 모두 포함하는 값에 사용
        - 용량 : 4바이트
        - 지원 범위 : 1970-01-01 00:00:00 ~ 2038-01-19 03:14:07

- 문자 타입
    > `CHAR`, `VARCHAR`, `TEXT`, `BLOB`, `ENUM`, `SET` 등  

    - CHAR와 VARCHAR
        > CHAR와 VARCHAR 모두 그 안에 수를 입력해서 몇 자까지 입력할 지 정함.  
        > EX) CHAR(30) : 최대 30글자까지 입력 가능  

        - **CHAR** : 고정 길이 문자열
            > 레코드를 저장할 때, 무조건 선언한 길이 값으로 '고정'해서 저장  
            > EX) CHAR(100) : 10글자를 저장해도 100바이트로 저장
            - 길이 : 0 ~ 255
            - 유동적이지 않은 길이를 가진 데이터의 경우에 효율적
        - **VARCHAR** : 가변 길이 문자열
            > 입력된 데이터에 따라 용량을 가변시켜 저장  
            > EX) VARCHAR(100) : 10글자를 저장할 경우, {(10글자에 해당하는 바이트) + (길이 기록용 1바이트)}로 저장
            - 길이 : 0 ~ 65,535
            - 유동적인 길이를 가진 데이터에 적합
    
    - TEXT와 BLOB
        > 두 개의 타입 모두 큰 데이터를 저장할 때 쓰는 타입  

        - **TEXT** : 큰 문자열 저장에 씀. 주로 게시판 본문 저장할 때 사용
        - **BLOB** : 이미지, 동영상 등 큰 데이터 저장에 사용
            - 보통은 서버(아마존의 이미지 호스팅 서비스인 S3를 이용 등)에 파일을 올리고 파일에 관한 경로를 VARCHAR로 저장

    - ENUM과 SET
        > 두 개의 타입 모두 문자열을 열거한 타입  
        > 공간적으로 이점을 얻을 수 있음.  
        > 애플리케이션의 수정에 따라 데이터베이스의 ENUM이나 SET에서 정의한 목록을 수정해야한다는 단점이 있음.
        - **ENUM**
            - `x-small`, `small`, `medium`, `large`, `x-large` 형태로 사용  
            - 위 중 하나만 선택하는 단일 선택만 가능  
            - 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입됨.
            - x-small 등이 0, 1 등으로 매핑되어 메모리 사용지 적음.
            - 최대 65,535개의 요소를 넣을 수 있음.
        - **SET**
            - ENUM과 비슷하지만 여러 개의 데이터를 선택 가능
            - 비트 단위의 연산 가능
            - 최대 64개의 요소를 집어넣을 수 있음.

---

### 4.1.6 관계
> 데이터베이스에는 여러 개의 테이블이 있고 이러한 테이블 간의 관계를 화살표로 나타냅니다.  

![관계 화살표](https://github.com/user-attachments/assets/065891a1-d09d-4670-9c2f-d32aadce753a)  


#### 1:1 관계
> 테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 만들어 줌.  
> EX) 유저 당 유저 이메일이 한 개씩 있는 관계  

![1:1 관계](https://github.com/user-attachments/assets/9cd79455-b635-4180-b6ed-da85419ed555)  


#### 1:N 관계
> 한 개체가 다른 많은 개체를 포함하는 관계  
> EX) 쇼핑몰에서 한 유저당 여러 개의 상품을 장바구니에 넣을 수 있을 때, 유저와 상품의 관계  
> 상품을 하나도 넣지 않는 0개의 경우도 있으므로 **0도 포함되는 화살표로 표현**

![1:N 관계](https://github.com/user-attachments/assets/41d6acd7-4548-4b2c-8ec9-26fdf2348877)  


#### N:M 관계
> EX) 학생과 강의의 관계 : 학생도 강의를 많이 들을 수 있고 강의도 여러 명의 학생을 포함할 수 있음.

![N:M 관계](https://github.com/user-attachments/assets/7603624e-87f7-4bde-99fe-0d997cea1238)  

학생 테이블과 강의 테이블 중간에 `학생_강의` 테이블이 끼어있어서  
N:M 관계의 두 테이블을 직접적으로 연결해서 구축하지 않고 `1:N`, `1:M` 관계를 갖는 테이블 **2개**로 나눠서 설정합니다.  

---

### 4.1.7 키
> 테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치 

- 종류
    - 슈퍼키 : 유일성
    - 후보키 : 유일성 + 최소성
    - 기본키
    - 대체키 : 후보키 中 기본키로 선택되지 못한 키
    - 외래키

<table>
  <tr>
    <td style="border-radius:5px; background-color:rgba(255, 255, 255, 0.07); padding:10px;"><b>유일성</b><br>
중복되는 값이 없음<br><br>
<b>최소성</b><br>
필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 것</td></tr></table>

<br><br>

**키 간의 관계**  
![키 간의 관계](https://github.com/user-attachments/assets/ac2d3f42-d55b-475c-aea3-a53d55c716b0)  

<br><br>

#### 기본키(PK; Primary Key = 프라이머리키)
> 유일성과 최소성을 만족하는 키  
> 테이블의 데이터 중 고유하게 존재하는 속성  

- 기본키에 해당하는 데이터는 중복되어서는 안됩니다.

  ![기본키가 안되는 키](https://github.com/user-attachments/assets/491c9ca8-ff32-4a5b-912c-810bcefd77b4)   
  *위 표에서 ID 필드에서 PDT0002 데이터가 중복으로 존재합니다.   
  ID 필드는 중복된 데이터가 존재하기 때문에  
  ID 필드는 기본키가 될 수 없습니다.*
  <br><br>

- 기본키가 되는 키
  
  ![기본키가 되는 키](https://github.com/user-attachments/assets/be3ac0d7-2843-4f48-84af-ac74d91f0da7)  
  *위의 테이블에서 ID 필드는 중복된 데이터가 존재하지 않으므로 기본키로 설정 가능합니다.  
  {ID, name}와 같이 복합키를 기본키로 설정할 수도 있지만 이렇게 하면 최소성을 만족하지 않습니다.*

  <br><br>
  
- 기본키는 **자연키** 또는 **인조키** 중에 골라 설정합니다.
    - `자연키`
        - 예시 : 유저 테이블 만들기
            - 속성 : `주민등록번호`, `이름`, `성별` 등
            - 위 속성 중 `이름`, `성별` 등은 중복된 데이터가 존재할 수 있으므로 부적절
            - 위의 속성 중 `주민등록번호`와 같이  
                중복된 값이 존재할 수 있는 속성을 제외하며 중복되지 않는 속성을 뽑다가 '자연스럽게' 나오는 키를 **자연키**라고 합니다.
        - 자연키는 언젠가는 변하는 속성을 가짐
    - `인조키`
        - 예시 : 유저 테이블 만들 때, 회원 테이블을 생성하는 경우
            - 속성 : `주민등록번호`, `이름`, `성별` 등  
            - 위의 속성에 인위적으로 `유저 아이디`를 부여 → 고유 식별자가 생성됨.
        - 인위적으로 생성한 키
        - 설정 방법
            - 오라클 : sequence
            - MySQL: auto Increment 
        - 자연키와 대조적으로 변하지 않음.
        - 보통 기본키는 인조키로 설정

<br>

#### 외래키(FK; Foreign Key)
> 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는 데 사용

- 외래키는 중복 허용
  
  ![외래키는 중복 허용](https://github.com/user-attachments/assets/9a5fa541-22cb-4065-9ebc-81ac17786c4d)  
  *위의 두 테이블을 보면 client 테이블의 기본키인 ID가 product 테이블의 user_id라는 외래키로 설정되었습니다.  
  그리고 user_id 필드에서 a_2라는 중복된 데이터를 갖는 것을 볼 수 있습니다.*

<br>

#### 후보키(Candidate Key)
> 기본키가 될 수 있는 후보들  
> 유일성과 최소성을 동시에 만족하는 키

<br>

#### 대체키(Alternate Key)
> 후보키가 두 개 이상일 경우, 어느 하나을 기본키로 지정하고 남은 후보키들을 말합니다.  

<br>

#### 슈퍼키(Super Key)
> 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키  
